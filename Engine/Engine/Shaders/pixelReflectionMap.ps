Texture2D    Texture[3];      // diffuse, normal, emissive
SamplerState SampleType[2]; // wrap,clamp 	
 
 struct PointLight
{
	float3 position;
	float radius;
	float3 color;
	float intensity;	
	float attConstant;
	float attLinear;
	float attExponential;
	int numLights;
};

cbuffer AmbientDirectionalBuffer : register(b0)
{
	float4 ambientColor;
	float4 dirDiffuseColor;
	float3 dirLightDirection;
}

cbuffer PointLightBuffer : register(b1)
{
	PointLight pointLights[1024];
};
 
struct PixelInputType
{
    float4 position    : SV_POSITION;
    float2 texCoord    : TEXCOORD0;
	float3 normal      : NORMAL;
	float3 tangent     : TANGENT;
	float3 binormal    : BINORMAL;
	float4 vertexColor : COLOR;
	float3 worldPos    : TEXCOORD1;
	float clip         : SV_ClipDistance0;	
};

float4 GetBaseColor(PixelInputType input)
{
	return (Texture[0].Sample(SampleType[0], input.texCoord) * input.vertexColor) * ambientColor;
}

float4 GetDirectionalColor(PixelInputType input)
{										  
	// sample from textures, multiply texturecolor with light percent to get blured shadow edges		
	float4 textureColor = Texture[0].Sample(SampleType[0], input.texCoord);		
	float4 normalMap    = Texture[1].Sample(SampleType[0], input.texCoord);
				
	// transform normal map value into -1 to 1 range
	normalMap = (normalMap * 2.0) -1.0;
	
	float3x3 tangentSpaceMatrix = float3x3(input.tangent, input.binormal, input.normal);
	float3 bumpNormal           = normalize(mul(normalMap, tangentSpaceMatrix));   	
			    		  					   		
    float lightIntensity = saturate(dot(bumpNormal.xyz, dirLightDirection)); 
	
	// get color based on texture, intensity and color of light
    float4 color = textureColor * input.vertexColor * lightIntensity * dirDiffuseColor; 
	saturate(color);
				
	return color; 
}

float4 GetPointColor(PixelInputType input)
{   
	float4 finalColor = float4(0,0,0,1);
	int numLights     = pointLights[0].numLights;
	
	for (int i =0; i < numLights; i++)
	{	
		// get light direction and distance from light	
		float3 lightDir = -normalize(input.worldPos - pointLights[i].position);	
		float dst       = length(input.worldPos - pointLights[i].position);
		
		// calculate attuniation	
		float fallOff     = 1 - ((dst / pointLights[i].radius) * 0.5);	// make the falloff 50% slower then the radius to give more control of result depending of attuniation settings
		float attuniation = 1 / (pointLights[i].attConstant + pointLights[i].attLinear * dst + pointLights[i].attExponential * dst * dst);
		attuniation       = (attuniation * pointLights[i].intensity) * fallOff;
		
		if (fallOff >= 0)
		{	
			// sample from textures		
			float4 textureColor = Texture[0].Sample(SampleType[0], input.texCoord); 	
			float4 bumpValues   = Texture[1].Sample(SampleType[0], input.texCoord);
			
			// convert normalmap sample to range -1 to 1
			bumpValues = (bumpValues * 2.0) -1.0;
			
			// get tangentSpaceMatrix for normalmapping and multiply with normalmapsample to get the bumpnormal
			float3x3 tangentSpaceMatrix = float3x3(input.tangent,input.binormal,input.normal);	
			float3 bumpNormal           = normalize(mul(bumpValues, tangentSpaceMatrix));   
				
			// get intensity from the normal from normalmap and lightdirection
			float lightIntensity = saturate(dot(bumpNormal, lightDir)); 
			
			// get color based on texture, intensity and color of light
			float4 color = textureColor * input.vertexColor * lightIntensity * float4(pointLights[i].color,1); 
							
			finalColor += (color * attuniation);
		}
	}
     
    return finalColor;
}

float4 Main(PixelInputType input) : SV_TARGET
{     	           	 
	// for now we only do a very simple reflection and ignore lightning 
	float4 baseColor      = GetBaseColor(input);
	float4 emissiveColor  = Texture[2].Sample(SampleType[0], input.texCoord);
		
	float4 directionalColor = GetDirectionalColor(input);
	float4 pointColor       = GetPointColor(input);
	
	// flag the alpha channel of diffuse map so the planar reflection shader knows that this is a emissive pixel
	// and should reflect stronger the other pixels
	if (emissiveColor.a > 0)
		return float4(Texture[0].Sample(SampleType[0], input.texCoord) * emissiveColor.rgb, -1);
			
	return baseColor + directionalColor + pointColor;
}