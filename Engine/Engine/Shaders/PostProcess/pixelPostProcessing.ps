Texture2D    Texture[4];    // Scenemap, bloomMap, dofmap, sceneDepth 
SamplerState SampleType[2]; // wrap,clamp 	

uniform int    u_applyBloom;
uniform float  u_bloomIntensity;
uniform int    u_applyDof;
uniform int    pad;
uniform float2 u_dofStartEndDst;

static float nearPlane = 0.1;
static float farPlane  = 5000.0;

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 texCoord : TEXCOORD0;		
};

float4 CalculateBloomColor(float2 texCoord)
{
	return Texture[1].Sample(SampleType[1], texCoord);
}

float InverseLerp(float a, float b, float t)
{
	return saturate((t - a) / (b - a));
}

float GetLinearDeapth(float pixeldepth)
{
	return 2.0 * nearPlane * farPlane / (farPlane + nearPlane - (2.0 * pixeldepth - 1.0) * (farPlane - nearPlane));
}

float4 Main(PixelInputType input) : SV_TARGET
{          
	float4 bloomColor = float4(0,0,0,1);	
	float4 baseColor  = Texture[0].Load(int3(input.position.xy,0));
	float4 dofColor   = Texture[2].Load(int3(input.position.xy,0));
	float4 depth      = Texture[3].Load(int3(input.position.xy,0));
	float4 finalColor = float4(0,0,0,1);
	float dofFraction = 0.0f;
	
	if (u_applyBloom == 1) bloomColor  = CalculateBloomColor(input.texCoord);
	if (u_applyDof == 1)   dofFraction = InverseLerp(u_dofStartEndDst.x, u_dofStartEndDst.y, GetLinearDeapth(depth.x));
	
	baseColor  = lerp(baseColor, dofColor, dofFraction);
	
	finalColor = baseColor + (bloomColor * u_bloomIntensity);
	
	return finalColor;
}






























