#include "CommonPixel.ps"

Texture2D    Texture[3];      // diffuse, normal, emissive
SamplerState SampleType[2]; // wrap,clamp 	

cbuffer AmbientDirectionalBuffer : register(b0)
{
	float4 ambientColor;
	float4 dirDiffuseColor;
	float3 dirLightDirection;
}

cbuffer PointLightBuffer : register(b1)
{
	PointLight pointLights[1024];
};
 
struct PixelInputType
{
    float4 position    : SV_POSITION;
    float2 texCoord    : TEXCOORD0;
	float3 normal      : NORMAL;
	float3 tangent     : TANGENT;
	float3 binormal    : BINORMAL;
	float4 vertexColor : COLOR;
	float3 worldPos    : TEXCOORD1;
	float clip         : SV_ClipDistance0;	
};

float3 GetBaseColor(PixelInputType input, float3 textureColor)
{
	return (textureColor * input.vertexColor.rgb) * ambientColor.rgb;
}

float3 GetDirectionalColor(PixelInputType input, float3 textureColor, float3 bumpNormal)
{										  									    		  					   		
    float lightIntensity = saturate(dot(bumpNormal, dirLightDirection)); 
	
	// get color based on texture, intensity and color of light
    return textureColor * input.vertexColor.rgb * lightIntensity * dirDiffuseColor.rgb; 
}

float3 GetPointColor(PixelInputType input, float4 textureColor, float3 bumpValues)
{   
	float4 finalColor = float4(0,0,0,1);
	int numLights = pointLights[0].numLights;
	for (int i =0; i < numLights; i++)		
		finalColor += GetPointLightColor(pointLights[i], input.worldPos, float3(0,0,0), textureColor, bumpValues, float4(0,0,0,0), false);
     
    return finalColor.rgb;
}

float4 Main(PixelInputType input) : SV_TARGET
{     	           	 
	float4 textureColor  = Texture[0].Sample(SampleType[0], input.texCoord);		
	float4 normalMap     = Texture[1].Sample(SampleType[0], input.texCoord);
	float4 emissiveColor = Texture[2].Sample(SampleType[0], input.texCoord);
	
	// convert normalmap sample to range -1 to 1
	normalMap = (normalMap * 2.0) -1.0;
	
	float3x3 tangentSpaceMatrix = float3x3(input.tangent, input.binormal, input.normal);
	float3 bumpNormal           = normalize(mul(normalMap, tangentSpaceMatrix));   
	
	float3 baseColor        = GetBaseColor(input, textureColor);		
	float3 directionalColor = GetDirectionalColor(input, textureColor, bumpNormal);
	float3 pointColor       = GetPointColor(input, textureColor, bumpNormal);

	if (emissiveColor.a > 0)
		return float4(textureColor * emissiveColor.rgb, 1);
			
	return float4(baseColor + directionalColor + pointColor, textureColor.a);
}