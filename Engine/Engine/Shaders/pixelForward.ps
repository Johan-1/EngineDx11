#include "CommonPixel.ps"

Texture2D Texture[5];	    // diffuse, normal, specular, emissive, shadowmap
SamplerState SampleType[2]; // wrap,clamp 	

cbuffer AmbientDirectionalBuffer : register(b0)
{
	float4 ambientColor;
	float4 dirDiffuseColor;
	float3 dirLightDirection;
}

cbuffer PointLightBuffer : register(b1)
{
	PointLight pointLights[1024];
};

struct PixelInputType
{
    float4 position           : SV_POSITION;
    float2 texCoord           : TEXCOORD0;
	float3 normal             : NORMAL;
	float3 tangent            : TANGENT;
	float3 binormal           : BINORMAL;
	float3 vertexToCamera     : TEXCOORD1;
	float4 positionLightSpace : TEXCOORD2;
	float3 worldPos           : TEXCOORD3;
	float4 vertexColor        : COLOR;
};

float3 GetBaseColor(PixelInputType input, float3 textureColor)
{
	return (textureColor * input.vertexColor) * ambientColor;
}

float3 GetDirectionalColor(PixelInputType input, float3 textureColor, float3 bumpNormal, float4 specularMap)
{
	// get how much the pixel is occluded
	float lightPercent = GetShadowLightFraction(Texture[4], SampleType[1], input.positionLightSpace, 0.00001);
	
	// return no light if completely occluded
	if(lightPercent == 0)
		return float4(0,0,0,0);
	
    // get light intensity 	
    float lightIntensity = saturate(dot(bumpNormal.xyz, dirLightDirection)); 
	
	float3 vtcNormalized = normalize(input.vertexToCamera);
	// get color based on texture, intensity and color of light
    float3 color = (textureColor * input.vertexColor.rgb * lightIntensity * dirDiffuseColor.rgb) * lightPercent; 
			
	return color + GetSpecularColorPhong(vtcNormalized, dirLightDirection, dirDiffuseColor, lightIntensity, bumpNormal, specularMap);
}

float3 GetPointColor(PixelInputType input, float4 textureColor, float3 bumpNormal, float4 specularMap)
{   
	float4 finalColor = float4(0,0,0,1);
	int numLights = pointLights[0].numLights;
	float3 vtcNormalized = normalize(input.vertexToCamera);
	for (int i =0; i < numLights; i++)		
		finalColor += GetPointLightColor2(pointLights[i], input.worldPos, vtcNormalized, textureColor, bumpNormal, specularMap, true);
     
    return finalColor;
}

float4 Main(PixelInputType input) : SV_TARGET
{						
	// if the alpha channel of the emissivemap is zero it means that this is 
	// an emissive pixel and should not recive lightning
	float4 emissiveMap = Texture[3].Sample(SampleType[0],input.texCoord);
	if (emissiveMap.a > 0)	
		return float4(Texture[0].Sample(SampleType[0],input.texCoord).rgb * emissiveMap.rgb, 1);
	
	float4 textureColor = Texture[0].Sample(SampleType[0], input.texCoord);;		
	float4 normalMap    = Texture[1].Sample(SampleType[0], input.texCoord);
	float4 specularMap  = Texture[2].Sample(SampleType[0], input.texCoord);
	
	// convert normalmap sample to range -1 to 1
	normalMap = (normalMap * 2.0) -1.0;
	
	// get normal in worldspace
    float3x3 tangentSpaceMatrix = float3x3(input.tangent,input.binormal,input.normal);	
    float3 bumpNormal           = normalize(mul(normalMap, tangentSpaceMatrix));  
	
	float3 baseColor        = GetBaseColor(input, textureColor.rgb);
	float3 directionalColor = GetDirectionalColor(input, textureColor.rgb, bumpNormal, specularMap);
	float3 pointColor       = GetPointColor(input, textureColor, bumpNormal, specularMap);
	
			
	return float4(baseColor + directionalColor + pointColor, textureColor.a);
}






