
#include "CommonPixel.ps"

Texture2D    Texture[5]; // shadowmap, position, normal, diffuse, specular	
SamplerState SampleType[2]; // wrap,clamp 	

cbuffer AmbientDirectionalBuffer : register(b0)
{
	float4 ambientColor;
	float4 lightColorDir;
	float3 lightDirectionDir;
}

cbuffer PointLightBuffer : register(b1)
{
	PointLight pointLights[1024];
};

cbuffer MiscBuffer : register(b2)
{
	float4x4 lightViewProj;
	float4   cameraPosition;
}

struct PixelInputType
{
    float4 position : SV_POSITION;	
};

float4 GetAmbientColor(float4 diffuseMap)
{
	return diffuseMap * ambientColor;
}

float4 GetDirectionalColor(float4 position, float4 diffuse, float4 normal, float4 specularMap)
{	
	// calculate the position in clip space of light
	float4 positionLightSpace = mul(position, lightViewProj);
	
	// get how much this pixel is luminated or in shadow
	float lightPercent = GetShadowLightFraction(Texture[0], SampleType[1], positionLightSpace, 0.00001);
	
	// return no light if completely occluded
	if(lightPercent == 0)
		return float4(0,0,0,0);
										  
	// get strength of texture color depending on how this pixel is occluded		
	float4 textureColor = diffuse * lightPercent;
			   
    // get how hard the light hits the surface			   
    float lightIntensity = saturate(dot(normal.xyz, lightDirectionDir)); 
	
	// get color based on texture, intensity and color of light
    return (textureColor * lightIntensity * lightColorDir) + GetSpecularColorPhong(cameraPosition.xyz, position.xyz, lightDirectionDir, lightColorDir, lightIntensity, normal.xyz, specularMap); 
}

float4 GetPointColor(float4 position, float4 diffuse, float4 normal, float4 specularMap)
{
	float4 finalColor = float4(0,0,0,1);
	int numLights = pointLights[0].numLights;
	for (int i =0; i < numLights; i++)		
		finalColor += GetPointLightColor(pointLights[i], position.xyz, cameraPosition, diffuse, normal.xyz, specularMap, true);
	    
    return finalColor;
}

float4 Main(PixelInputType input) : SV_TARGET
{            
	// alpha channel is flagged as 0 in the diffusemap if this is an emissive pixel
	// dont do any lightning calculations and only return the emissive
	// color that is stored in the diffuse map
	float4 diffuse  = Texture[3].Load(int3(input.position.xy,0));
	if (diffuse.a == 0)	
		return diffuse;
		
	float4 position = Texture[1].Load(int3(input.position.xy,0));
	float4 normal   = Texture[2].Load(int3(input.position.xy,0));
	float4 specular = Texture[4].Load(int3(input.position.xy,0));		
		
	float4 finalColor = float4(0,0,0,1);

	float4 ambientColor     = GetAmbientColor(diffuse);
	float4 directionalColor = GetDirectionalColor(position, diffuse, normal, specular);
	float4 pointColor       = GetPointColor(position, diffuse, normal, specular);
	
	finalColor = ambientColor + directionalColor + pointColor;
	
    return finalColor;	   
}






























